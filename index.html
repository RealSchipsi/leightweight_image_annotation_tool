<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Annotation Tool</title>
  </head>
  <body
    style="
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
    "
  >
    <style>
      .container {
        border-style: solid;
        border-color: #f3f3f3;
        height: 700px;
        width: 1150px;
        background-color: #ffffff;
        font-family: Arial, Helvetica, sans-serif;
      }

      .uploadContainer {
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      .uploadContainerHeader {
        height: 10%;
        width: 100%;
        display: flex;
      }

      .uploadContainerHeader img {
        margin-left: 5%;
        margin-top: 2.5%;
        height: 97.5%;
      }

      .uploadContainerBody {
        height: 87.5%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      .uploadButton {
        margin-top: 50px;
        background-color: #009682;
        color: #ffffff;
        width: 175px;
        height: 45px;
        border-radius: 25px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .uploadButton:hover {
        background-color: rgba(0, 150, 130, 0.748);
      }

      #annotationContainer {
        display: none;
      }

      .uploadContainerFooter {
        height: 2.5%;
        width: 100%;
        background-color: #009682;
      }

      .annotationContainer {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
      }

      .annotationContainerHead {
        display: flex;
        flex-direction: row;
        height: 7%;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
      }

      .annotationContainerHeadLeft {
        width: 30%;
        display: flex;
        align-items: center;
        padding: 0% 0.5%;
      }

      .annotationContainerHeadLeft img {
        height: 80%;
      }

      .annotationContainerHeadCenter {
        width: 50%;
        display: flex;
      }

      .adjustmentSlider p {
        margin-right: 10px;
      }

      .adjustmentSlider {
        display: flex;
        align-items: center;
        margin-right: 20px;
      }

      input[type="range"] {
        -webkit-appearance: none;
      }

      input[type="range"]::-webkit-slider-runnable-track {
        width: 300px;
        height: 5px;
        background: #ddd;
        border: none;
        border-radius: 3px;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        border: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: #009682;
        margin-top: -5px;
      }

      input[type="range"]:focus {
        outline: none;
      }

      input[type="range"]:focus::-webkit-slider-runnable-track {
        background: #ccc;
      }

      .annotationContainerHeadRight {
        display: flex;
        flex-direction: row;
        width: 20%;
        justify-content: flex-end;
        align-items: center;
        padding: 0% 1.5%;
      }

      .topNavBtn {
        border-radius: 7px;
        height: 90%;
        color: #222222;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin-left: 20px;
      }

      .topNavBtn i {
        margin-top: 25%;
        font-size: 15px;
        margin-bottom: -15%;
      }

      .topNavBtn p {
        font-size: 12px;
      }

      .topNavBtn:hover {
        color: rgba(34, 34, 34, 0.748);
      }

      .annotationContainerBody {
        display: flex;
        flex-direction: row;
        height: 93%;
      }

      .annotationContainerBodyLeft {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 3.5%;
      }

      .annotationContainerBodyLeftSection {
        padding-top: 10px;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
      }

      .annotation-btn {
        width: 80%;
        height: 32px;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 10px;
        cursor: pointer;
        color: #222222;
      }

      .annotation-btn:hover {
        color: rgb(34, 34, 34, 0.748);
      }

      .annotation-btn i {
        font-size: 18px;
      }

      .annotation-btn.active {
        background-color: #f3f3f3;
      }

      .annotationContainerBodyCenter {
        width: 80%;
        background-color: #ffffff;
        border-left-style: solid;
        border-left-color: #f3f3f3;
        border-right-style: solid;
        border-right-color: #f3f3f3;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
      }

      .annotationContainerBodyCenter img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        -webkit-user-drag: none; /* Deaktiviert das Ziehen in Webkit-Browsern (Chrome, Safari) */
        user-select: none; /* Verhindert die Text- und Bildeingabe */
      }

      .annotationContainerBodyRight {
        width: 16.5%;
        height: 100%;
      }

      .annotationContainerBodyRightHeader {
        display: flex;
        align-items: center;
        padding-left: 10px;
        height: 5%;
        color: #222222;
      }

      .annotationContainerBodyRightBody {
        height: 95%;
        overflow-y: auto;
      }

      .annotationList {
        list-style-type: none;
        margin: 0;
        padding: 2.5px 0;
      }

      .annotationItem {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
        margin: 2.5px 5px;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
        background-color: #f3f3f35e;
      }

      .annotationItemLeft {
        display: flex;
        flex-direction: column;
        width: 85%;
      }

      .annotationType {
        font-size: 10px;
        color: #222222;
      }

      .annotationLabel {
        font-size: 12px;
        margin: 5px 0;
      }

      .annotationItemLeft input {
        padding: 5px;
        border-radius: 5px;
        border: 1px solid #f3f3f3;
        width: 85%;
      }

      .annotationItemRight {
        width: 15%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .removeAnnotationBtn {
        cursor: pointer;
      }

      .removeAnnotationBtn i {
        color: #222222;
      }

      .adjustment-slider {
        width: 100%;
        margin: 12px 0 0 0;
      }

      .overlay-controls {
        position: absolute;
        margin-top: -600px;
        margin-left: 470px;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 15px 25px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        transition: all 0.3s ease;
        backdrop-filter: blur(8px);
        min-width: 200px;
      }

      .overlay-controls.visible {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .adjustment-slider {
        -webkit-appearance: none;
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background: #e0e0e0;
        outline: none;
        transition: all 0.3s ease;
      }

      .adjustment-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #009682;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
      }

      .adjustment-slider::-webkit-slider-thumb:hover {
        transform: scale(1.1);
        background: #007a6a;
      }

      #finishPolylineBtn {
        border-style: solid;
        border-color: #009682;
        color: #009682;
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        text-align: center;
        font-size: 14px;
      }

      #finishPolylineBtn:hover {
        border-color: rgba(0, 150, 130, 0.748);
        color: rgba(0, 150, 130, 0.748);
      }

      .slider-label {
        display: flex;
        align-items: center;
        gap: 10px;
        color: #333;
        font-size: 14px;
        font-weight: 500;
      }

      .slider-label i {
        color: #009682;
        font-size: 16px;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <div class="container">
      <div id="uploadContainer" class="uploadContainer">
        <div class="uploadContainerHeader">
          <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Logo_KIT.svg/1280px-Logo_KIT.svg.png"
            alt=""
          />
        </div>
        <div class="uploadContainerBody">
          <h1>Beginne die Bildannotation</h1>
          <div id="uploadButton" class="uploadButton">Bild hochladen</div>
          <input type="file" id="fileInput" accept="image/*" hidden />
        </div>
        <div class="uploadContainerFooter"></div>
      </div>
      <div id="annotationContainer" class="annotationContainer">
        <div class="annotationContainerHead">
          <div class="annotationContainerHeadLeft">
            <img
              src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Logo_KIT.svg/1280px-Logo_KIT.svg.png"
              alt=""
            />
          </div>
          <div class="annotationContainerHeadCenter"></div>
          <div class="annotationContainerHeadRight">
            <div class="topNavBtn">
              <i class="fas fa-save"></i>
              <p>Speichern</p>
            </div>
            <div class="topNavBtn" onclick="removeFile()">
              <i class="fas fa-times"></i>
              <p>Neustart</p>
            </div>
          </div>
        </div>
        <div class="annotationContainerBody">
          <div class="annotationContainerBodyLeft">
            <div class="annotationContainerBodyLeftSection">
              <div id="pointerBtn" class="annotation-btn" title="Pointer">
                <i class="fas fa-mouse-pointer"></i>
              </div>
            </div>
            <div class="annotationContainerBodyLeftSection">
              <div
                id="boundingBoxBtn"
                class="annotation-btn"
                title="Bounding Box"
              >
                <i class="fas fa-vector-square"></i>
              </div>
              <div id="polylineBtn" class="annotation-btn" title="Polylinie">
                <i class="fas fa-draw-polygon"></i>
              </div>
            </div>
            <div class="annotationContainerBodyLeftSection">
              <div id="brightnessBtn" class="annotation-btn" title="Helligkeit">
                <i class="far fa-sun"></i>
              </div>
              <div id="contrastBtn" class="annotation-btn" title="Kontrast">
                <i class="fas fa-adjust"></i>
              </div>
            </div>
          </div>
          <div class="annotationContainerBodyCenter">
            <img id="uploadedImageDisplay" src="" alt="Uploaded Image" />
            <canvas
              id="annotationCanvas"
              width="920"
              height="650"
              style="position: absolute; margin-left: -920px"
            ></canvas>
            <div class="overlay-controls" id="overlayControls">
              <!-- Brightness Controls -->
              <div id="brightnessControls" style="display: none">
                <div class="slider-label">
                  <i class="fa-regular fa-sun"></i>
                  <span>Helligkeit:</span>
                  <span id="brightnessValue">0</span>
                </div>
                <input
                  type="range"
                  id="brightnessSlider"
                  class="adjustment-slider"
                  min="-100"
                  max="100"
                  value="0"
                />
              </div>

              <!-- Contrast Controls -->
              <div id="contrastControls" style="display: none">
                <div class="slider-label">
                  <i class="fa-solid fa-circle-half-stroke"></i>
                  <span>Kontrast:</span>
                  <span id="contrastValue">0</span>
                </div>
                <input
                  type="range"
                  id="contrastSlider"
                  class="adjustment-slider"
                  min="-100"
                  max="100"
                  value="0"
                />
              </div>

              <!-- Polyline Controls -->
              <div id="polylineControls" style="display: none">
                <div id="finishPolylineBtn">Polylinie beenden</div>
              </div>
            </div>
          </div>
          <div class="annotationContainerBodyRight">
            <div class="annotationContainerBodyRightHeader">
              <h4>Objekte</h4>
            </div>
            <div class="annotationContainerBodyRightBody">
              <ul class="annotationList" id="annotationList"></ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      // File upload and deletion
      const uploadBtn = document.getElementById("uploadButton");
      const fileInput = document.getElementById("fileInput");
      const uploadedImageDisplay = document.getElementById(
        "uploadedImageDisplay"
      );

      let uploadedImage = null; // Variable to store the uploaded image

      function initUpload() {
        uploadBtn.addEventListener("click", handleUploadClick);
        fileInput.addEventListener("change", handleFileChange);
      }

      function handleUploadClick() {
        fileInput.click(); // Trigger the file input click event
      }

      function handleFileChange(event) {
        if (event.target.files.length > 0) {
          uploadedImage = event.target.files[0]; // Store the uploaded image in the variable

          const reader = new FileReader();
          reader.onload = function (e) {
            uploadedImageDisplay.src = e.target.result; // Set the src attribute
          };
          reader.readAsDataURL(uploadedImage);

          console.log("Bild erfolgreich hochgeladen:", uploadedImage);

          document.getElementById("uploadContainer").style.display = "none";
          document.getElementById("annotationContainer").style.display = "flex";

          // Reset the file input value to ensure change event is triggered next time
          fileInput.value = "";
        }
      }

      function removeFile() {
        const removeButton = document.getElementById("removeButton");

        uploadedImageDisplay.src = ""; // Clears the src attribute to remove the image
        uploadedImage = null;

        console.log("Bild wurde entfernt.");

        document.getElementById("uploadContainer").style.display = "flex";
        document.getElementById("annotationContainer").style.display = "none";

        // Clear annotations
        annotations = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        updateAnnotationList(); // Update the list
      }

      // Initialize the upload functionality
      initUpload();

      // Annotation features
      const canvas = document.getElementById("annotationCanvas");
      const ctx = canvas.getContext("2d");
      const boundingBoxBtn = document.getElementById("boundingBoxBtn");
      const polylineBtn = document.getElementById("polylineBtn");
      const finishPolylineBtn = document.getElementById("finishPolylineBtn");
      const pointerBtn = document.getElementById("pointerBtn");
      let currentType = ""; // Default type
      let startX,
        startY,
        isDrawing = false;
      let currentPoints = []; // For storing polyline points
      let annotations = []; // Array to store all annotations
      let selectedAnnotation = null;
      let offsetX, offsetY;
      let isResizing = false;
      let resizeHandleSize = 10;

      // Initialize buttons with click events
      function initAnnotationTool() {
        boundingBoxBtn.addEventListener("click", () =>
          selectAnnotationType("boundingBox")
        );
        polylineBtn.addEventListener("click", () =>
          selectAnnotationType("polyline")
        );
        finishPolylineBtn.addEventListener("click", finishPolyline);
        pointerBtn.addEventListener("click", () =>
          selectAnnotationType("pointer")
        );

        canvas.addEventListener("mousedown", startDrawing);
        canvas.addEventListener("mousemove", drawAnnotation);
        canvas.addEventListener("mouseup", stopDrawing);
        canvas.addEventListener("mousedown", (e) => {
          e.preventDefault();
          e.stopPropagation();
          // Zeichnen starten
        });
      }

      function updateAnnotationList() {
        const annotationList = document.getElementById("annotationList");
        annotationList.innerHTML = ""; // Clear the current list

        annotations.forEach((ann, index) => {
          const listItem = document.createElement("li");

          // Map the annotation type to a more readable format
          const annotationType =
            ann.type === "boundingBox" ? "Bounding Box" : "Polylinie";

          // Create a complex structure using template literals
          const annotationItem = document.createElement("div");
          annotationItem.className = "annotationItem";
          annotationItem.style.border = `2px solid ${ann.color}`;
          annotationItem.style.backgroundColor = `${ann.color}33`;

          const annotationItemLeft = document.createElement("div");
          annotationItemLeft.className = "annotationItemLeft";

          const annotationTypeDiv = document.createElement("div");
          annotationTypeDiv.className = "annotationType";
          annotationTypeDiv.textContent = annotationType;

          const annotationLabelInput = document.createElement("input");
          annotationLabelInput.className = "annotationLabel";
          annotationLabelInput.placeholder = "Label";
          annotationLabelInput.value = ann.label;

          annotationItemLeft.appendChild(annotationTypeDiv);
          annotationItemLeft.appendChild(annotationLabelInput);

          const annotationItemRight = document.createElement("div");
          annotationItemRight.className = "annotationItemRight";

          const removeAnnotationBtn = document.createElement("div");
          removeAnnotationBtn.className = "removeAnnotationBtn";

          const removeIcon = document.createElement("i");
          removeIcon.className = "fas fa-times";

          removeAnnotationBtn.appendChild(removeIcon);
          annotationItemRight.appendChild(removeAnnotationBtn);

          annotationItem.appendChild(annotationItemLeft);
          annotationItem.appendChild(annotationItemRight);

          listItem.appendChild(annotationItem);

          // Add event listener to update the label on input change
          listItem
            .querySelector(".annotationLabel")
            .addEventListener("input", (e) => {
              ann.label = e.target.value;
              redrawAnnotations(); // Redraw annotations with updated labels
            });

          // Add event listener to remove annotation on button click
          listItem
            .querySelector(".removeAnnotationBtn")
            .addEventListener("click", () => removeAnnotation(index));

          // Append the list item to the annotation list
          annotationList.appendChild(listItem);
        });
      }

      function removeAnnotation(index) {
        annotations.splice(index, 1); // Remove the annotation from the array
        updateAnnotationList(); // Update the list
        redrawAnnotations(); // Redraw annotations
      }

      function removeSelectedAnnotation() {
        if (selectedAnnotation) {
          const index = annotations.indexOf(selectedAnnotation);
          if (index !== -1) {
            removeAnnotation(index);
          }
          selectedAnnotation = null;
        }
      }

      function selectAnnotationType(type) {
        currentType = type;

        // Remove active class from ALL buttons including brightness and contrast
        document.querySelectorAll(".annotation-btn").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Hide sliders and reset adjustments
        document.getElementById("brightnessSlider").style.display = "none";
        document.getElementById("contrastSlider").style.display = "none";
        isBrightnessMode = false;
        isContrastMode = false;

        // Reset image adjustments
        brightness = 0;
        contrast = 0;
        document.getElementById("brightnessSlider").value = 0;
        document.getElementById("contrastSlider").value = 0;
        document.getElementById("uploadedImageDisplay").style.filter = "none";

        // Set active class only for annotation type buttons
        if (type === "boundingBox") {
          boundingBoxBtn.classList.add("active");
          finishPolylineBtn.style.display = "none";
        } else if (type === "polyline") {
          polylineBtn.classList.add("active");
          finishPolylineBtn.style.display = "block";
        } else if (type === "pointer") {
          pointerBtn.classList.add("active");
          finishPolylineBtn.style.display = "none";
        }
      }

      function startDrawing(e) {
        if (currentType === "pointer") {
          selectedAnnotation = getResizeHandleAt(e.offsetX, e.offsetY);
          if (selectedAnnotation) {
            isResizing = true;
            offsetX = e.offsetX;
            offsetY = e.offsetY;
          } else {
            selectedAnnotation = getAnnotationAt(e.offsetX, e.offsetY);
            if (selectedAnnotation) {
              if (selectedAnnotation.type === "boundingBox") {
                offsetX = e.offsetX - selectedAnnotation.x;
                offsetY = e.offsetY - selectedAnnotation.y;
              } else if (selectedAnnotation.type === "polyline") {
                offsetX = e.offsetX;
                offsetY = e.offsetY;
              }
              isDrawing = true;
            }
          }
        } else {
          startX = e.offsetX;
          startY = e.offsetY;
          isDrawing = true;

          if (currentType === "polyline") {
            currentPoints.push({ x: startX, y: startY });
            showControl("polylineControls"); // Show the button when starting to draw a polyline
          }
        }
      }

      function drawAnnotation(e) {
        if (!isDrawing && !isResizing) return;

        requestAnimationFrame(() => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          redrawAnnotations();

          if (currentType === "boundingBox") {
            const width = e.offsetX - startX;
            const height = e.offsetY - startY;
            drawBoundingBox(startX, startY, width, height, "#009682");
          } else if (currentType === "polyline" && currentPoints.length > 0) {
            drawPolyline(
              [...currentPoints, { x: e.offsetX, y: e.offsetY }],
              "#009682"
            );
          } else if (currentType === "pointer" && selectedAnnotation) {
            if (isResizing) {
              const handleIndex = selectedAnnotation.handleIndex;
              const ann = selectedAnnotation.annotation;
              if (ann.type === "boundingBox") {
                switch (handleIndex) {
                  case 0: // top-left
                    ann.width += ann.x - e.offsetX;
                    ann.height += ann.y - e.offsetY;
                    ann.x = e.offsetX;
                    ann.y = e.offsetY;
                    break;
                  case 1: // top-middle
                    ann.height += ann.y - e.offsetY;
                    ann.y = e.offsetY;
                    break;
                  case 2: // top-right
                    ann.width = e.offsetX - ann.x;
                    ann.height += ann.y - e.offsetY;
                    ann.y = e.offsetY;
                    break;
                  case 3: // middle-left
                    ann.width += ann.x - e.offsetX;
                    ann.x = e.offsetX;
                    break;
                  case 4: // middle-right
                    ann.width = e.offsetX - ann.x;
                    break;
                  case 5: // bottom-left
                    ann.width += ann.x - e.offsetX;
                    ann.height = e.offsetY - ann.y;
                    ann.x = e.offsetX;
                    break;
                  case 6: // bottom-middle
                    ann.height = e.offsetY - ann.y;
                    break;
                  case 7: // bottom-right
                    ann.width = e.offsetX - ann.x;
                    ann.height = e.offsetY - ann.y;
                    break;
                }
                drawBoundingBox(
                  ann.x,
                  ann.y,
                  ann.width,
                  ann.height,
                  ann.color,
                  true
                ); // Highlight the bounding box when resizing
              } else if (ann.type === "polyline") {
                if (
                  handleIndex === 0 ||
                  handleIndex === ann.points.length - 1
                ) {
                  // Ensure the first and last points remain the same
                  ann.points[0] = { x: e.offsetX, y: e.offsetY };
                  ann.points[ann.points.length - 1] = {
                    x: e.offsetX,
                    y: e.offsetY,
                  };
                } else {
                  ann.points[handleIndex] = { x: e.offsetX, y: e.offsetY };
                }
                drawPolyline(ann.points, ann.color, true);
              }
            } else {
              if (selectedAnnotation.type === "boundingBox") {
                selectedAnnotation.x = e.offsetX - offsetX;
                selectedAnnotation.y = e.offsetY - offsetY;
              } else if (selectedAnnotation.type === "polyline") {
                const dx = e.offsetX - offsetX;
                const dy = e.offsetY - offsetY;
                selectedAnnotation.points = selectedAnnotation.points.map(
                  (point) => ({
                    x: point.x + dx,
                    y: point.y + dy,
                  })
                );
                offsetX = e.offsetX;
                offsetY = e.offsetY;
              }
            }
            redrawAnnotations(true);
            updateAnnotationList(); // Update the list
          }
        });
      }

      function stopDrawing(e) {
        isDrawing = false;
        isResizing = false;
        selectedAnnotation = null;

        if (currentType === "boundingBox") {
          const width = e.offsetX - startX;
          const height = e.offsetY - startY;
          const label = prompt("Label hinzufügen:");
          if (label !== null && label.trim() !== "") {
            annotations.push({
              type: "boundingBox",
              x: startX,
              y: startY,
              width,
              height,
              label,
              color: getRandomColor(), // Assign a random color
            });
            updateAnnotationList(); // Update the list
            redrawAnnotations(); // Redraw annotations
          }
        } else if (currentType === "polyline") {
          currentPoints.push({ x: e.offsetX, y: e.offsetY });
        }
      }

      function finishPolyline() {
        if (currentPoints.length > 1) {
          const label = prompt("Label hinzufügen:");
          if (label !== null && label.trim() !== "") {
            // Add the first point to the end to close the polyline
            currentPoints.push(currentPoints[0]);

            annotations.push({
              type: "polyline",
              points: [...currentPoints],
              label,
              color: getRandomColor(), // Assign a random color
            });
            currentPoints = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            redrawAnnotations(); // Redraw annotations
            updateAnnotationList(); // Update the list
            hideAllControls(); // Hide the overlay controls when finished
          } else {
            currentPoints = []; // Clear the points if the label is not provided
            hideAllControls(); // Hide the overlay controls if canceled
          }
        }
      }

      function drawBoundingBox(x, y, width, height, color, highlight = false) {
        ctx.strokeStyle = highlight ? "#009682" : color;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        ctx.fillStyle = highlight ? "#00968233" : color + "33"; // Set fill color with transparency
        ctx.fillRect(x, y, width, height); // Fill the bounding box
        ctx.fillStyle = highlight ? "#009682" : color; // Set text color
        ctx.font = "12px Arial"; // Set text font

        if (highlight) {
          const handles = [
            { x: x, y: y }, // top-left
            { x: x + width / 2, y: y }, // top-middle
            { x: x + width, y: y }, // top-right
            { x: x, y: y + height / 2 }, // middle-left
            { x: x + width, y: y + height / 2 }, // middle-right
            { x: x, y: y + height }, // bottom-left
            { x: x + width / 2, y: y + height }, // bottom-middle
            { x: x + width, y: y + height }, // bottom-right
          ];
          handles.forEach((handle) => {
            ctx.fillRect(
              handle.x - resizeHandleSize / 2,
              handle.y - resizeHandleSize / 2,
              resizeHandleSize,
              resizeHandleSize
            );
          });
        }
      }

      function drawPolyline(points, color, highlight = false) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        points.forEach((point) => ctx.lineTo(point.x, point.y));
        ctx.strokeStyle = highlight ? "#009682" : color;
        ctx.lineWidth = 2;
        ctx.stroke();
        if (
          points.length > 2 &&
          points[0].x === points[points.length - 1].x &&
          points[0].y === points[points.length - 1].y
        ) {
          ctx.fillStyle = highlight ? "#00968233" : color + "33"; // Set fill color with transparency
          ctx.fill(); // Fill the closed polyline
        }

        if (highlight) {
          points.forEach((point) => {
            ctx.fillStyle = "#009682";
            ctx.fillRect(
              point.x - resizeHandleSize / 2,
              point.y - resizeHandleSize / 2,
              resizeHandleSize,
              resizeHandleSize
            );
          });
        }
      }

      function redrawAnnotations(highlight = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        annotations.forEach((ann) => {
          if (ann.type === "boundingBox") {
            drawBoundingBox(
              ann.x,
              ann.y,
              ann.width,
              ann.height,
              ann.color,
              highlight && ann === selectedAnnotation
            );
            ctx.fillStyle = ann === selectedAnnotation ? "#009682" : ann.color; // Set text color
            ctx.font = "12px Arial"; // Set text font
            ctx.fillText(ann.label, ann.x, ann.y - 5); // Draw label above bounding box
          } else if (ann.type === "polyline") {
            drawPolyline(
              ann.points,
              ann.color,
              highlight && ann === selectedAnnotation
            );
            ctx.fillStyle = ann === selectedAnnotation ? "#009682" : ann.color; // Set text color
            ctx.font = "12px Arial"; // Set text font
            ctx.fillText(ann.label, ann.points[0].x, ann.points[0].y - 5); // Draw label at the start of polyline
          }
        });
      }

      function getAnnotationAt(x, y) {
        for (let i = annotations.length - 1; i >= 0; i--) {
          const ann = annotations[i];
          if (ann.type === "boundingBox") {
            if (
              x >= ann.x &&
              x <= ann.x + ann.width &&
              y >= ann.y &&
              y <= ann.y + ann.height
            ) {
              return ann;
            }
          } else if (ann.type === "polyline") {
            if (isPointInPolygon(ann.points, { x, y })) {
              return ann;
            }
            for (let j = 0; j < ann.points.length - 1; j++) {
              const point1 = ann.points[j];
              const point2 = ann.points[j + 1];
              if (isPointOnLineSegment(point1, point2, { x, y })) {
                return ann;
              }
            }
          }
        }
        return null;
      }

      function isPointOnLineSegment(point1, point2, point) {
        const tolerance = 10; // Increase tolerance for easier selection
        const distance =
          Math.abs(
            (point2.y - point1.y) * point.x -
              (point2.x - point1.x) * point.y +
              point2.x * point1.y -
              point2.y * point1.x
          ) /
          Math.sqrt(
            Math.pow(point2.y - point1.y, 2) + Math.pow(point2.x - point1.x, 2)
          );
        return distance <= tolerance;
      }

      function isPointInPolygon(points, point) {
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
          const xi = points[i].x,
            yi = points[i].y;
          const xj = points[j].x,
            yj = points[j].y;

          const intersect =
            yi > point.y !== yj > point.y &&
            point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function getResizeHandleAt(x, y) {
        for (let i = annotations.length - 1; i >= 0; i--) {
          const ann = annotations[i];
          if (ann.type === "boundingBox") {
            const handles = [
              { x: ann.x, y: ann.y }, // top-left
              { x: ann.x + ann.width / 2, y: ann.y }, // top-middle
              { x: ann.x + ann.width, y: ann.y }, // top-right
              { x: ann.x, y: ann.y + ann.height / 2 }, // middle-left
              { x: ann.x + ann.width, y: ann.y + ann.height / 2 }, // middle-right
              { x: ann.x, y: ann.y + ann.height }, // bottom-left
              { x: ann.x + ann.width / 2, y: ann.y + ann.height }, // bottom-middle
              { x: ann.x + ann.width, y: ann.y + ann.height }, // bottom-right
            ];
            for (let j = 0; j < handles.length; j++) {
              const handle = handles[j];
              if (
                x >= handle.x - resizeHandleSize / 2 &&
                x <= handle.x + resizeHandleSize / 2 &&
                y >= handle.y - resizeHandleSize / 2 &&
                y <= handle.y + resizeHandleSize / 2
              ) {
                return { annotation: ann, handleIndex: j };
              }
            }
          } else if (ann.type === "polyline") {
            for (let j = 0; j < ann.points.length; j++) {
              const point = ann.points[j];
              if (
                x >= point.x - resizeHandleSize / 2 &&
                x <= point.x + resizeHandleSize / 2 &&
                y >= point.y - resizeHandleSize / 2 &&
                y <= point.y + resizeHandleSize / 2
              ) {
                return { annotation: ann, handleIndex: j };
              }
            }
          }
        }
        return null;
      }

      function getRandomColor() {
        const letters = "0123456789ABCDEF";
        let color = "#";
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      function saveAnnotationsToLocalStorage() {
        const canvasDimensions = {
          width: canvas.width,
          height: canvas.height,
        };

        const data = {
          canvasDimensions,
          annotations,
          brightness,
          contrast,
        };

        localStorage.setItem("annotations", JSON.stringify(data));
      }

      function downloadAnnotations() {
        const canvasDimensions = {
          width: canvas.width,
          height: canvas.height,
        };

        const data = {
          canvasDimensions,
          annotations,
          brightness,
          contrast,
        };

        const dataStr = JSON.stringify(data, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const exportFileDefaultName = "annotations.json";

        const linkElement = document.createElement("a");
        linkElement.setAttribute("href", url);
        linkElement.setAttribute("download", exportFileDefaultName);
        document.body.appendChild(linkElement); // Required for Firefox
        linkElement.click();
        document.body.removeChild(linkElement); // Cleanup
        URL.revokeObjectURL(url); // Free up memory
      }

      document
        .querySelector(".topNavBtn i.fa-save")
        .parentElement.addEventListener("click", () => {
          saveAnnotationsToLocalStorage();
          downloadAnnotations();
        });

      // Add these variables
      let isBrightnessMode = false;
      let isContrastMode = false;
      let brightness = 0;
      let contrast = 0;

      // Add event listeners
      document
        .getElementById("brightnessSlider")
        .addEventListener("input", updateBrightness);
      document
        .getElementById("contrastSlider")
        .addEventListener("input", updateContrast);

      function updateBrightness(e) {
        brightness = e.target.value;
        document.getElementById("brightnessValue").innerText = brightness;
        applyImageAdjustments();
      }

      function updateContrast(e) {
        contrast = e.target.value;
        document.getElementById("contrastValue").innerText = contrast;
        applyImageAdjustments();
      }

      function applyImageAdjustments() {
        const img = document.getElementById("uploadedImageDisplay");
        img.style.filter = `brightness(${
          100 + parseInt(brightness)
        }%) contrast(${100 + parseInt(contrast)}%)`;
      }

      // Reset function for when switching to other modes
      function resetImageAdjustments() {
        brightness = 0;
        contrast = 0;
        document.getElementById("brightnessSlider").value = 0;
        document.getElementById("contrastSlider").value = 0;
        document.getElementById("uploadedImageDisplay").style.filter = "none";
      }

      let activeMode = null;

      function hideAllControls() {
        document.getElementById("overlayControls").style.display = "none";
        document.getElementById("brightnessControls").style.display = "none";
        document.getElementById("contrastControls").style.display = "none";
        document.getElementById("polylineControls").style.display = "none";
      }

      function showControl(controlId) {
        document.getElementById("overlayControls").style.display = "block";
        document.getElementById(controlId).style.display = "block";
      }

      function selectMode(mode) {
        // If the same mode is clicked, do nothing
        if (activeMode === mode) return;

        // Reset states
        currentType = null;
        activeMode = mode;

        // Reset UI
        document
          .querySelectorAll(".annotation-btn")
          .forEach((btn) => btn.classList.remove("active"));
        hideAllControls();

        // Handle mode selection
        switch (mode) {
          case "brightness":
            document.getElementById("brightnessBtn").classList.add("active");
            showControl("brightnessControls");
            break;

          case "contrast":
            document.getElementById("contrastBtn").classList.add("active");
            showControl("contrastControls");
            break;

          case "polyline":
            currentType = "polyline";
            document.getElementById("polylineBtn").classList.add("active");
            if (currentPoints.length > 0) {
              showControl("polylineControls");
            }
            break;

          case "boundingBox":
            currentType = "boundingBox";
            document.getElementById("boundingBoxBtn").classList.add("active");
            break;

          case "pointer":
            currentType = "pointer";
            document.getElementById("pointerBtn").classList.add("active");
            break;
        }
      }

      // Initialize event listeners
      function initAnnotationTool() {
        document
          .getElementById("boundingBoxBtn")
          .addEventListener("click", () => selectMode("boundingBox"));
        document
          .getElementById("polylineBtn")
          .addEventListener("click", () => selectMode("polyline"));
        document
          .getElementById("pointerBtn")
          .addEventListener("click", () => selectMode("pointer"));
        document
          .getElementById("brightnessBtn")
          .addEventListener("click", () => selectMode("brightness"));
        document
          .getElementById("contrastBtn")
          .addEventListener("click", () => selectMode("contrast"));

        document
          .getElementById("brightnessSlider")
          .addEventListener("input", updateBrightness);
        document
          .getElementById("contrastSlider")
          .addEventListener("input", updateContrast);

        document
          .getElementById("finishPolylineBtn")
          .addEventListener("click", finishPolyline);

        canvas.addEventListener("mousedown", startDrawing);
        canvas.addEventListener("mousemove", drawAnnotation);
        canvas.addEventListener("mouseup", stopDrawing);

        // Ensure overlay controls are hidden initially
        hideAllControls();
      }

      // Call initAnnotationTool to set up event listeners
      initAnnotationTool();
    </script>
  </body>
</html>
