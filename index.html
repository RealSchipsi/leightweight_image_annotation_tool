<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lightweight Image Annotation Tool</title>
  </head>
  <body
    style="
      height: 100%;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    "
  >
    <!-- COPY FROM HERE FOR EMBEDDING TOOL IN ScoSci Survey -->
    <style>
      .container {
        border-style: solid;
        border-color: #f3f3f3;
        height: 700px;
        width: 1150px; /* Width of Survey Tool */
        background-color: #ffffff;
        font-family: Arial, Helvetica, sans-serif;
      }

      .upload-container {
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      .upload-container-header {
        height: 10%;
        width: 100%;
        display: flex;
      }

      .upload-container-header img {
        margin-left: 5%;
        margin-top: 2.5%;
        height: 97.5%;
      }

      .upload-container-body {
        height: 87.5%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      .upload-button {
        margin-top: 50px;
        background-color: #009682;
        color: #ffffff;
        width: 175px;
        height: 45px;
        border-radius: 25px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .upload-button:hover {
        background-color: rgba(0, 150, 130, 0.748);
      }

      #annotation-container {
        display: none;
      }

      .upload-container-footer {
        height: 2.5%;
        width: 100%;
        background-color: #009682;
      }

      .annotation-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
      }

      .annotation-container-head {
        display: flex;
        flex-direction: row;
        height: 7%;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
      }

      .annotation-container-head-left {
        width: 30%;
        display: flex;
        align-items: center;
        padding: 0% 0.5%;
      }

      .annotation-container-head-left img {
        height: 80%;
      }

      .annotation-container-head-center {
        width: 50%;
        display: flex;
      }

      .adjustment-slider p {
        margin-right: 10px;
      }

      .adjustment-slider {
        display: flex;
        align-items: center;
        margin-right: 20px;
      }

      input[type="range"] {
        -webkit-appearance: none;
      }

      input[type="range"]::-webkit-slider-runnable-track {
        width: 300px;
        height: 5px;
        background-color: #ddd;
        border: none;
        border-radius: 3px;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        border: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background-color: #009682;
        margin-top: -5px;
      }

      input[type="range"]:focus {
        outline: none;
      }

      input[type="range"]:focus::-webkit-slider-runnable-track {
        background-color: #ccc;
      }

      .annotation-container-head-right {
        display: flex;
        flex-direction: row;
        width: 20%;
        justify-content: flex-end;
        align-items: center;
        padding: 0% 1.5%;
      }

      .top-nav-button {
        height: 90%;
        color: #222222;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin-left: 30px;
      }

      .top-nav-button i {
        margin-top: 25%;
        font-size: 15px;
        margin-bottom: -15%;
      }

      .top-nav-button p {
        font-size: 12px;
      }

      .top-nav-button:hover {
        color: rgba(34, 34, 34, 0.748);
      }

      .annotation-container-body {
        display: flex;
        flex-direction: row;
        height: 93%;
      }

      .annotation-container-body-left {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 3.5%;
        border-right-style: solid;
        border-right-color: #f3f3f3;
      }

      .annotation-container-body-left-section {
        padding-top: 10px;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
      }

      .annotation-button {
        width: 80%;
        height: 32px;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 10px;
        cursor: pointer;
        color: #222222;
      }

      .annotation-button:hover {
        color: rgb(34, 34, 34, 0.748);
      }

      .annotation-button i {
        font-size: 18px;
      }

      .annotation-button.active {
        background-color: #f3f3f3;
      }

      .annotation-container-body-center {
        width: 80%;
        height: 99.6%;
        background-color: #ffffff;
      }

      .annotation-container-body-center img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        -webkit-user-drag: none; /* Disables dragging in Webkit browsers (Chrome, Safari) */
        user-select: none; /* Prevents text and image selection */
      }

      .annotation-container-body-right {
        width: 16.5%;
        height: 100%;
        border-left-style: solid;
        border-left-color: #f3f3f3;
      }

      .annotation-container-body-right-header {
        display: flex;
        align-items: center;
        padding-left: 10px;
        height: 5%;
        color: #222222;
      }

      .annotation-container-body-right-body {
        height: 95%;
        overflow-y: auto;
      }

      .annotation-list {
        list-style-type: none;
        margin: 0;
        padding: 2.5px 0;
      }

      .annotation-item {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
        margin: 2.5px 5px;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
        background-color: #f3f3f35e;
      }

      .annotation-item-left {
        display: flex;
        flex-direction: column;
        width: 85%;
      }

      .annotation-type {
        font-size: 10px;
        color: #222222;
      }

      .annotation-label {
        font-size: 12px;
        margin: 5px 0;
      }

      .annotation-item-left input {
        padding: 5px;
        border-radius: 5px;
        border: 1px solid #f3f3f3;
        width: 85%;
      }

      .annotation-item-right {
        width: 15%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .remove-annotation-button {
        cursor: pointer;
      }

      .remove-annotation-button i {
        color: #222222;
      }

      .adjustment-slider {
        width: 100%;
        margin: 12px 0 0 0;
      }

      .overlay-controls {
        position: absolute;
        margin-top: -600px; /* Relative to container and not window */
        margin-left: 470px; /* Relative to container and not window */
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.95);
        padding: 15px 25px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        transition: all 0.3s ease;
        backdrop-filter: blur(8px);
        min-width: 200px;
      }

      .overlay-controls.visible {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .adjustment-slider {
        -webkit-appearance: none;
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background-color: #e0e0e0;
        outline: none;
        transition: all 0.3s ease;
      }

      .adjustment-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background-color: #009682;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
      }

      .adjustment-slider::-webkit-slider-thumb:hover {
        transform: scale(1.1);
        background-color: #007a6a;
      }

      #finish-polyline-button {
        border-style: solid;
        border-color: #009682;
        color: #009682;
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        text-align: center;
        font-size: 14px;
      }

      #finish-polyline-button:hover {
        border-color: rgba(0, 150, 130, 0.748);
        color: rgba(0, 150, 130, 0.748);
      }

      .slider-label {
        display: flex;
        align-items: center;
        gap: 10px;
        color: #333;
        font-size: 14px;
        font-weight: 500;
      }

      .slider-label i {
        color: #009682;
        font-size: 16px;
      }

      .label-input-group {
        display: flex;
        gap: 10px;
        align-items: center;
        background-color: white;
        padding: 5px;
        border-radius: 8px;
      }

      .label-input {
        flex: 1;
        padding: 10px 15px;
        border: 2px solid #e0e0e0;
        border-radius: 6px;
        font-size: 14px;
        transition: all 0.2s ease;
        outline: none;
      }

      .label-input:focus {
        border-color: #009682;
        box-shadow: 0 0 0 2px rgba(0, 150, 130, 0.1);
      }

      .save-label-button {
        background-color: #009682;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
      }

      .save-label-button:hover {
        background-color: #007a6a;
      }

      .save-label-button i {
        font-size: 12px;
      }

      .cancel-label-button {
        background-color: #ff6b6b;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
      }

      .cancel-label-button:hover {
        background-color: #e55a5a;
      }

      .cancel-label-button i {
        font-size: 12px;
      }

      .overlay-submit-background {
        position: absolute;
        height: 700px;
        width: 1150px;
        z-index: 1000;
        justify-content: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.5);
      }

      .overlay-submit {
        background-color: #ffffff;
        border-radius: 12px;
        width: 600px;
        height: 200px;
      }

      .restart-annotation-overlay,
      .leave-annotation-overlay {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        width: 100%;
      }

      .restart-annotation-overlay-content,
      .leave-annotation-overlay-content {
        padding: 20px;
        text-align: center;
      }

      .restart-annotation-overlay-buttons,
      .leave-annotation-overlay-buttons {
        display: flex;
        justify-content: space-around;
        margin-top: 20px;
      }

      .restart-annotation-button,
      .cancel-restart-annotation-button,
      .leave-annotation-button,
      .cancel-leave-annotation-button {
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
      }

      .restart-annotation-button,
      .leave-annotation-button {
        background-color: #009682;
        color: white;
        border: none;
      }

      .cancel-restart-annotation-button,
      .cancel-leave-annotation-button {
        background-color: #ff6b6b;
        color: white;
        border: none;
      }

      .restart-annotation-button:hover,
      .leave-annotation-button:hover {
        background-color: #007a6a;
      }

      .cancel-restart-annotation-button:hover,
      .cancel-leave-annotation-button:hover {
        background-color: #e55a5a;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <div class="container">
      <div id="upload-container" class="upload-container">
        <div class="upload-container-header">
          <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Logo_KIT.svg/1280px-Logo_KIT.svg.png"
            alt=""
          />
        </div>
        <div class="upload-container-body">
          <h1>Beginne die Bildannotation</h1>
          <div id="upload-button" class="upload-button">Bild hochladen</div>
          <input type="file" id="file-input" accept="image/*" hidden />
        </div>
        <div class="upload-container-footer"></div>
      </div>
      <div id="annotation-container" class="annotation-container">
        <div class="annotation-container-head">
          <div class="annotation-container-head-left">
            <img
              src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Logo_KIT.svg/1280px-Logo_KIT.svg.png"
              alt=""
            />
          </div>
          <div class="annotation-container-head-center"></div>
          <div class="annotation-container-head-right">
            <div class="top-nav-button">
              <i class="fas fa-refresh"></i>
              <p>Neustart</p>
            </div>
            <div class="top-nav-button">
              <i class="fas fa-save"></i>
              <p>Speichern</p>
            </div>
            <div class="top-nav-button">
              <i class="fas fa-home"></i>
              <p>Verlassen</p>
            </div>
          </div>
        </div>
        <div class="annotation-container-body">
          <div class="annotation-container-body-left">
            <div class="annotation-container-body-left-section">
              <div
                id="pointer-button"
                class="annotation-button"
                title="Pointer"
              >
                <i class="fas fa-mouse-pointer"></i>
              </div>
            </div>
            <div class="annotation-container-body-left-section">
              <div
                id="bounding-box-button"
                class="annotation-button"
                title="Bounding Box"
              >
                <i class="fas fa-vector-square"></i>
              </div>
              <div
                id="polyline-button"
                class="annotation-button"
                title="Polylinie"
              >
                <i class="fas fa-draw-polygon"></i>
              </div>
            </div>
            <div class="annotation-container-body-left-section">
              <div
                id="brightness-button"
                class="annotation-button"
                title="Helligkeit"
              >
                <i class="far fa-sun"></i>
              </div>
              <div
                id="contrast-button"
                class="annotation-button"
                title="Kontrast"
              >
                <i class="fas fa-adjust"></i>
              </div>
            </div>
          </div>
          <div class="annotation-container-body-center">
            <img id="uploaded-image-display" src="" alt="Uploaded Image" />
            <canvas
              id="annotation-canvas"
              width="920"
              height="650"
              style="position: absolute; margin-left: -920px"
            ></canvas>
            <div class="overlay-controls" id="overlay-controls">
              <div class="new-label" id="new-label" style="display: none">
                <div class="label-input-group">
                  <input
                    type="text"
                    id="annotation-label-input"
                    placeholder="Label eingeben..."
                    class="label-input"
                  />
                  <button id="save-label-button" class="save-label-button">
                    <i class="fas fa-check"></i>
                    Speichern
                  </button>
                  <button id="cancel-label-button" class="cancel-label-button">
                    <i class="fas fa-times"></i>
                    Abbruch
                  </button>
                </div>
              </div>
              <div id="brightness-controls" style="display: none">
                <div class="slider-label">
                  <i class="fa-regular fa-sun"></i>
                  <span>Helligkeit:</span>
                  <span id="brightness-value">0</span>
                </div>
                <input
                  type="range"
                  id="brightness-slider"
                  class="adjustment-slider"
                  min="-100"
                  max="100"
                  value="0"
                />
              </div>
              <div id="contrast-controls" style="display: none">
                <div class="slider-label">
                  <i class="fa-solid fa-circle-half-stroke"></i>
                  <span>Kontrast:</span>
                  <span id="contrast-value">0</span>
                </div>
                <input
                  type="range"
                  id="contrast-slider"
                  class="adjustment-slider"
                  min="-100"
                  max="100"
                  value="0"
                />
              </div>
              <div id="polyline-controls" style="display: none">
                <div id="finish-polyline-button">Polylinie beenden</div>
              </div>
            </div>
          </div>
          <div class="annotation-container-body-right">
            <div class="annotation-container-body-right-header">
              <h4>Objekte</h4>
            </div>
            <div class="annotation-container-body-right-body">
              <ul class="annotation-list" id="annotation-list"></ul>
            </div>
          </div>
        </div>
        <div
          class="overlay-submit-background"
          id="overlay-submit"
          style="display: none"
        >
          <div class="overlay-submit">
            <div
              id="restart-annotation-overlay"
              class="restart-annotation-overlay"
              style="display: none"
            >
              <div class="restart-annotation-overlay-content">
                <h3>Neustart</h3>
                <p>Möchtest du die aktuelle Annotation verlassen?</p>
                <div class="restart-annotation-overlay-buttons">
                  <div
                    id="restart-annotation-button"
                    class="restart-annotation-button"
                  >
                    Ja
                  </div>
                  <div
                    id="cancel-restart-annotation-button"
                    class="cancel-restart-annotation-button"
                  >
                    Nein
                  </div>
                </div>
              </div>
            </div>
            <div
              id="leave-annotation-overlay"
              class="leave-annotation-overlay"
              style="display: none"
            >
              <div class="leave-annotation-overlay-content">
                <h3>Verlassen</h3>
                <p>Möchtest du die aktuelle Annotation zurücksetzen?</p>
                <div class="leave-annotation-overlay-buttons">
                  <div
                    id="leave-annotation-button"
                    class="leave-annotation-button"
                  >
                    Ja
                  </div>
                  <div
                    id="cancel-leave-annotation-button"
                    class="cancel-leave-annotation-button"
                  >
                    Nein
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      // File upload and deletion
      const uploadButton = document.getElementById("upload-button");
      const fileInput = document.getElementById("file-input");
      const uploadedImageDisplay = document.getElementById(
        "uploaded-image-display"
      );

      let uploadedImage = null; // Variable to store the uploaded image

      function initUpload() {
        uploadButton.addEventListener("click", handleUploadClick);
        fileInput.addEventListener("change", handleFileChange);
      }

      function handleUploadClick() {
        fileInput.click(); // Trigger the file input click event
      }

      // Handle the file change event
      function handleFileChange(event) {
        if (event.target.files.length > 0) {
          uploadedImage = event.target.files[0]; // Store the uploaded image in the variable

          const reader = new FileReader();
          reader.onload = function (e) {
            uploadedImageDisplay.src = e.target.result; // Set the src attribute
          };
          reader.readAsDataURL(uploadedImage);

          document.getElementById("upload-container").style.display = "none";
          document.getElementById("annotation-container").style.display =
            "flex";

          // Reset the file input value to ensure change event is triggered next time
          fileInput.value = "";
        }
      }

      // Remove the uploaded image
      function removeFile() {
        const removeButton = document.getElementById("remove-button");

        uploadedImageDisplay.src = ""; // Clears the src attribute to remove the image
        uploadedImage = null;

        document.getElementById("upload-container").style.display = "flex";
        document.getElementById("annotation-container").style.display = "none";

        // Clear annotations
        annotations = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        updateAnnotationList(); // Update the list

        contrast = 0;
        brightness = 0;

        document.getElementById("contrast-value").innerText = contrast;
        document.getElementById("brightness-value").innerText = brightness;

        applyImageAdjustments();

        // Remove annotations from local storage
        localStorage.removeItem("annotations");
      }

      // Annotation features
      const canvas = document.getElementById("annotation-canvas");
      const ctx = canvas.getContext("2d");
      const boundingBoxButton = document.getElementById("bounding-box-button");
      const polylineButton = document.getElementById("polyline-button");
      const finishPolylineButton = document.getElementById(
        "finish-polyline-button"
      );
      const pointerButton = document.getElementById("pointer-button");
      let currentPoints = []; // Points while drawing annotation
      let currentType = null; // Current annotation type
      let activeMode = null; // Active mode (annotation or adjustment)
      let isDrawing = false;
      let startX, startY, endX, endY; // Coordinates for bounding box
      let annotations = []; // Array to store all annotations
      let selectedAnnotation = null; // Selected annotation for resizing
      let offsetX, offsetY; // Offset for resizing
      let isResizing = false;
      let resizeHandleSize = 10; // Size of resize handles

      // Initialize buttons with click events
      function initAnnotationTool() {
        boundingBoxButton.addEventListener("click", () =>
          selectAnnotationType("boundingBox")
        );
        polylineButton.addEventListener("click", () =>
          selectAnnotationType("polyline")
        );
        finishPolylineButton.addEventListener("click", finishPolyline);
        pointerButton.addEventListener("click", () =>
          selectAnnotationType("pointer")
        );

        canvas.addEventListener("mousedown", startDrawing);
        canvas.addEventListener("mousemove", drawAnnotation);
        canvas.addEventListener("mouseup", stopDrawing);
        canvas.addEventListener("mousedown", (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      }

      // Update the annotation list
      function updateAnnotationList() {
        const annotationList = document.getElementById("annotation-list");
        annotationList.innerHTML = ""; // Clear the current list

        annotations.forEach((ann, index) => {
          const listItem = document.createElement("li");

          // Map the annotation type to a more readable format
          const annotationType =
            ann.type === "boundingBox" ? "Bounding Box" : "Polylinie";

          // Create a complex structure using template literals
          const annotationItem = document.createElement("div");
          annotationItem.className = "annotation-item";
          annotationItem.style.border = `2px solid ${ann.color}`;
          annotationItem.style.backgroundColor = `${ann.color}33`;

          const annotationItemLeft = document.createElement("div");
          annotationItemLeft.className = "annotation-item-left";

          const annotationTypeDiv = document.createElement("div");
          annotationTypeDiv.className = "annotation-type";
          annotationTypeDiv.textContent = annotationType;

          const annotationLabelInput = document.createElement("input");
          annotationLabelInput.className = "annotation-label";
          annotationLabelInput.placeholder = "Label";
          annotationLabelInput.value = ann.label;

          annotationItemLeft.appendChild(annotationTypeDiv);
          annotationItemLeft.appendChild(annotationLabelInput);

          const annotationItemRight = document.createElement("div");
          annotationItemRight.className = "annotation-item-right";

          const removeAnnotationButton = document.createElement("div");
          removeAnnotationButton.className = "remove-annotation-button";

          const removeIcon = document.createElement("i");
          removeIcon.className = "fas fa-times";

          removeAnnotationButton.appendChild(removeIcon);
          annotationItemRight.appendChild(removeAnnotationButton);

          annotationItem.appendChild(annotationItemLeft);
          annotationItem.appendChild(annotationItemRight);

          listItem.appendChild(annotationItem);

          listItem
            .querySelector(".annotation-label")
            .addEventListener("input", (e) => {
              const oldLabel = ann.label;
              const newLabel = e.target.value;

              // Count how many times old label appears
              const oldLabelCount = annotations.filter(
                (a) => a.label === oldLabel
              ).length;

              // Update the label
              ann.label = newLabel;

              // Check if the new label already exists
              const existingAnnotation = annotations.find(
                (annotation) =>
                  annotation.label === newLabel && annotation !== ann
              );

              if (existingAnnotation) {
                // If the new label already exists, use the existing color
                ann.color = existingAnnotation.color;
              } else if (oldLabelCount > 1) {
                // If old label appeared multiple times, assign new color
                ann.color = getRandomColor();
              }
              // Keep original color if old label was unique

              // Update colors of annotations with the old label
              annotations.forEach((annotation) => {
                if (annotation.label === oldLabel) {
                  annotation.color = getColorForLabel(oldLabel);
                }
              });

              // Update the color of the annotation list item
              annotationItem.style.border = `2px solid ${ann.color}`;
              annotationItem.style.backgroundColor = `${ann.color}33`;

              // Redraw annotations without updating the annotation list
              redrawAnnotations();

              // Save to local storage
              saveAnnotationsToLocalStorage();
            });

          // Add event listener to remove annotation on button click
          listItem
            .querySelector(".remove-annotation-button")
            .addEventListener("click", () => removeAnnotation(index));

          // Append the list item to the annotation list
          annotationList.appendChild(listItem);
        });
      }

      // Select the annotation type
      function selectAnnotationType(type) {
        currentType = type;

        // Remove active class from ALL buttons including brightness and contrast
        document.querySelectorAll(".annotation-button").forEach((button) => {
          button.classList.remove("active");
        });

        // Hide sliders and reset adjustments
        document.getElementById("brightness-slider").style.display = "none";
        document.getElementById("contrast-slider").style.display = "none";
        isBrightnessMode = false;
        isContrastMode = false;

        // Reset image adjustments
        brightness = 0;
        contrast = 0;
        document.getElementById("brightness-slider").value = 0;
        document.getElementById("contrast-slider").value = 0;
        document.getElementById("uploaded-image-display").style.filter = "none";

        // Set active class only for annotation type buttons
        if (type === "boundingBox") {
          boundingBoxButton.classList.add("active");
          finishPolylineButton.style.display = "none";
        } else if (type === "polyline") {
          polylineButton.classList.add("active");
          finishPolylineButton.style.display = "block";
        } else if (type === "pointer") {
          pointerButton.classList.add("active");
          finishPolylineButton.style.display = "none";
        }
      }

      // Start drawing when mouse is pressed
      function startDrawing(e) {
        if (currentType === "pointer") {
          selectedAnnotation = getResizeHandleAt(e.offsetX, e.offsetY);
          if (selectedAnnotation) {
            isResizing = true;
            offsetX = e.offsetX;
            offsetY = e.offsetY;
          } else {
            selectedAnnotation = getAnnotationAt(e.offsetX, e.offsetY);
            if (selectedAnnotation) {
              if (selectedAnnotation.type === "boundingBox") {
                offsetX = e.offsetX - selectedAnnotation.x;
                offsetY = e.offsetY - selectedAnnotation.y;
              } else if (selectedAnnotation.type === "polyline") {
                offsetX = e.offsetX;
                offsetY = e.offsetY;
              }
              isDrawing = true;
            }
          }
        } else {
          startX = e.offsetX;
          startY = e.offsetY;
          isDrawing = true;

          if (currentType === "polyline") {
            currentPoints.push({ x: startX, y: startY });
            showControl("polyline-controls"); // Show the button when starting to draw a polyline
          }
        }
      }

      // Draw the annotation based on the current type
      function drawAnnotation(e) {
        if (!isDrawing && !isResizing) return;

        requestAnimationFrame(() => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          redrawAnnotations();

          if (currentType === "boundingBox") {
            const width = e.offsetX - startX;
            const height = e.offsetY - startY;
            drawBoundingBox(startX, startY, width, height, "#009682");
          } else if (currentType === "polyline" && currentPoints.length > 0) {
            drawPolyline(
              [...currentPoints, { x: e.offsetX, y: e.offsetY }],
              "#009682"
            );
          } else if (currentType === "pointer" && selectedAnnotation) {
            if (isResizing) {
              const handleIndex = selectedAnnotation.handleIndex;
              const ann = selectedAnnotation.annotation;
              if (ann.type === "boundingBox") {
                switch (handleIndex) {
                  case 0: // top-left
                    ann.width += ann.x - e.offsetX;
                    ann.height += ann.y - e.offsetY;
                    ann.x = e.offsetX;
                    ann.y = e.offsetY;
                    break;
                  case 1: // top-middle
                    ann.height += ann.y - e.offsetY;
                    ann.y = e.offsetY;
                    break;
                  case 2: // top-right
                    ann.width = e.offsetX - ann.x;
                    ann.height += ann.y - e.offsetY;
                    ann.y = e.offsetY;
                    break;
                  case 3: // middle-left
                    ann.width += ann.x - e.offsetX;
                    ann.x = e.offsetX;
                    break;
                  case 4: // middle-right
                    ann.width = e.offsetX - ann.x;
                    break;
                  case 5: // bottom-left
                    ann.width += ann.x - e.offsetX;
                    ann.height = e.offsetY - ann.y;
                    ann.x = e.offsetX;
                    break;
                  case 6: // bottom-middle
                    ann.height = e.offsetY - ann.y;
                    break;
                  case 7: // bottom-right
                    ann.width = e.offsetX - ann.x;
                    ann.height = e.offsetY - ann.y;
                    break;
                }
                drawBoundingBox(
                  ann.x,
                  ann.y,
                  ann.width,
                  ann.height,
                  ann.color,
                  true
                ); // Highlight the bounding box when resizing
              } else if (ann.type === "polyline") {
                if (
                  handleIndex === 0 ||
                  handleIndex === ann.points.length - 1
                ) {
                  // Ensure the first and last points remain the same
                  ann.points[0] = { x: e.offsetX, y: e.offsetY };
                  ann.points[ann.points.length - 1] = {
                    x: e.offsetX,
                    y: e.offsetY,
                  };
                } else {
                  ann.points[handleIndex] = { x: e.offsetX, y: e.offsetY };
                }
                drawPolyline(ann.points, ann.color, true);
              }
            } else {
              if (selectedAnnotation.type === "boundingBox") {
                selectedAnnotation.x = e.offsetX - offsetX;
                selectedAnnotation.y = e.offsetY - offsetY;
              } else if (selectedAnnotation.type === "polyline") {
                const dx = e.offsetX - offsetX;
                const dy = e.offsetY - offsetY;
                selectedAnnotation.points = selectedAnnotation.points.map(
                  (point) => ({
                    x: point.x + dx,
                    y: point.y + dy,
                  })
                );
                offsetX = e.offsetX;
                offsetY = e.offsetY;
              }
            }
            redrawAnnotations(true);
            updateAnnotationList(); // Update the list

            // Save to local storage
            saveAnnotationsToLocalStorage();
          }
        });
      }

      // Stop drawing when mouse is released
      function stopDrawing(e) {
        if (isDrawing) {
          if (currentType === "boundingBox") {
            endX = e.offsetX;
            endY = e.offsetY;

            // Show label input
            showControl("new-label");
            document.getElementById("annotation-label-input").value = "";
            document.getElementById("annotation-label-input").focus();
          }
          isDrawing = false;
        }
        isResizing = false; // Reset resizing state when mouse is released
      }

      // Remove annotation from the list and redraw annotations
      function removeAnnotation(index) {
        annotations.splice(index, 1); // Remove the annotation from the array
        updateAnnotationList(); // Update the list
        redrawAnnotations(); // Redraw annotations

        // Save to local storage
        saveAnnotationsToLocalStorage();
      }

      // Redraw all annotations
      function redrawAnnotations(highlight = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        annotations.forEach((ann) => {
          if (ann.type === "boundingBox") {
            drawBoundingBox(
              ann.x,
              ann.y,
              ann.width,
              ann.height,
              ann.color,
              highlight && ann === selectedAnnotation
            );
            ctx.fillStyle = ann === selectedAnnotation ? "#009682" : ann.color; // Set text color
            ctx.font = "12px Arial"; // Set text font
            ctx.fillText(ann.label, ann.x, ann.y - 5); // Draw label above bounding box
          } else if (ann.type === "polyline") {
            drawPolyline(
              ann.points,
              ann.color,
              highlight && ann === selectedAnnotation
            );
            ctx.fillStyle = ann === selectedAnnotation ? "#009682" : ann.color; // Set text color
            ctx.font = "12px Arial"; // Set text font
            ctx.fillText(ann.label, ann.points[0].x, ann.points[0].y - 5); // Draw label at the start of polyline
          }
        });
      }

      // Draw a bounding box with the specified dimensions
      function drawBoundingBox(x, y, width, height, color, highlight = false) {
        ctx.strokeStyle = highlight ? "#009682" : color;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        ctx.fillStyle = highlight ? "#00968233" : color + "33"; // Set fill color with transparency
        ctx.fillRect(x, y, width, height); // Fill the bounding box
        ctx.fillStyle = highlight ? "#009682" : color; // Set text color
        ctx.font = "12px Arial"; // Set text font

        if (highlight) {
          const handles = [
            { x: x, y: y }, // top-left
            { x: x + width / 2, y: y }, // top-middle
            { x: x + width, y: y }, // top-right
            { x: x, y: y + height / 2 }, // middle-left
            { x: x + width, y: y + height / 2 }, // middle-right
            { x: x, y: y + height }, // bottom-left
            { x: x + width / 2, y: y + height }, // bottom-middle
            { x: x + width, y: y + height }, // bottom-right
          ];
          handles.forEach((handle) => {
            ctx.fillRect(
              handle.x - resizeHandleSize / 2,
              handle.y - resizeHandleSize / 2,
              resizeHandleSize,
              resizeHandleSize
            );
          });
        }
      }

      // Draw a polyline with the specified points
      function drawPolyline(points, color, highlight = false) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        points.forEach((point) => ctx.lineTo(point.x, point.y));
        ctx.strokeStyle = highlight ? "#009682" : color;
        ctx.lineWidth = 2;
        ctx.stroke();
        if (
          points.length > 2 &&
          points[0].x === points[points.length - 1].x &&
          points[0].y === points[points.length - 1].y
        ) {
          ctx.fillStyle = highlight ? "#00968233" : color + "33"; // Set fill color with transparency
          ctx.fill(); // Fill the closed polyline
        }

        if (highlight) {
          points.forEach((point) => {
            ctx.fillStyle = "#009682";
            ctx.fillRect(
              point.x - resizeHandleSize / 2,
              point.y - resizeHandleSize / 2,
              resizeHandleSize,
              resizeHandleSize
            );
          });
        }
      }

      // Finish polyline drawing
      function finishPolyline() {
        if (currentPoints.length > 1) {
          const button = document.getElementById("finish-polyline-button");
          if (button) button.style.display = "none";
          showControl("new-label");
          document.getElementById("annotation-label-input").value = "";
          document.getElementById("annotation-label-input").focus();
        }
      }

      // Check if a point is inside an annotation
      function getAnnotationAt(x, y) {
        for (let i = annotations.length - 1; i >= 0; i--) {
          const ann = annotations[i];
          if (ann.type === "boundingBox") {
            if (
              x >= ann.x &&
              x <= ann.x + ann.width &&
              y >= ann.y &&
              y <= ann.y + ann.height
            ) {
              return ann;
            }
          } else if (ann.type === "polyline") {
            if (isPointInPolygon(ann.points, { x, y })) {
              return ann;
            }
            for (let j = 0; j < ann.points.length - 1; j++) {
              const point1 = ann.points[j];
              const point2 = ann.points[j + 1];
              if (isPointOnLineSegment(point1, point2, { x, y })) {
                return ann;
              }
            }
          }
        }
        return null;
      }

      // Check if a point is on a line segment
      function isPointOnLineSegment(point1, point2, point) {
        const tolerance = 10; // Increase tolerance for easier selection
        const distance =
          Math.abs(
            (point2.y - point1.y) * point.x -
              (point2.x - point1.x) * point.y +
              point2.x * point1.y -
              point2.y * point1.x
          ) /
          Math.sqrt(
            Math.pow(point2.y - point1.y, 2) + Math.pow(point2.x - point1.x, 2)
          );
        return distance <= tolerance;
      }

      // Check if a point is inside a polygon
      function isPointInPolygon(points, point) {
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
          const xi = points[i].x,
            yi = points[i].y;
          const xj = points[j].x,
            yj = points[j].y;

          const intersect =
            yi > point.y !== yj > point.y &&
            point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      // Get resize handle at the specified coordinates
      function getResizeHandleAt(x, y) {
        for (let i = annotations.length - 1; i >= 0; i--) {
          const ann = annotations[i];
          if (ann.type === "boundingBox") {
            const handles = [
              { x: ann.x, y: ann.y }, // top-left
              { x: ann.x + ann.width / 2, y: ann.y }, // top-middle
              { x: ann.x + ann.width, y: ann.y }, // top-right
              { x: ann.x, y: ann.y + ann.height / 2 }, // middle-left
              { x: ann.x + ann.width, y: ann.y + ann.height / 2 }, // middle-right
              { x: ann.x, y: ann.y + ann.height }, // bottom-left
              { x: ann.x + ann.width / 2, y: ann.y + ann.height }, // bottom-middle
              { x: ann.x + ann.width, y: ann.y + ann.height }, // bottom-right
            ];
            for (let j = 0; j < handles.length; j++) {
              const handle = handles[j];
              if (
                x >= handle.x - resizeHandleSize / 2 &&
                x <= handle.x + resizeHandleSize / 2 &&
                y >= handle.y - resizeHandleSize / 2 &&
                y <= handle.y + resizeHandleSize / 2
              ) {
                return { annotation: ann, handleIndex: j };
              }
            }
          } else if (ann.type === "polyline") {
            for (let j = 0; j < ann.points.length; j++) {
              const point = ann.points[j];
              if (
                x >= point.x - resizeHandleSize / 2 &&
                x <= point.x + resizeHandleSize / 2 &&
                y >= point.y - resizeHandleSize / 2 &&
                y <= point.y + resizeHandleSize / 2
              ) {
                return { annotation: ann, handleIndex: j };
              }
            }
          }
        }
        return null;
      }

      // Random color generator
      function getRandomColor() {
        // Predefined color palette for better visual consistency
        const colors = [
          "#FF6B6B", // Red
          "#4ECDC4", // Turquoise
          "#45B7D1", // Blue
          "#96CEB4", // Mint
          "#FFBE0B", // Yellow
          "#FF006E", // Pink
          "#8338EC", // Purple
          "#3A86FF", // Royal Blue
          "#FB5607", // Orange
          "#38B000", // Green
        ];

        // Get random color from palette
        const randomIndex = Math.floor(Math.random() * colors.length);

        // Check if color is already in use
        const usedColors = annotations.map((a) => a.color);
        if (!usedColors.includes(colors[randomIndex])) {
          return colors[randomIndex];
        }

        // If all palette colors used, generate random color
        let color = "#";
        const letters = "0123456789ABCDEF";
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      // Get color for label
      function getColorForLabel(label) {
        const existingAnnotation = annotations.find(
          (ann) => ann.label === label
        );
        return existingAnnotation ? existingAnnotation.color : getRandomColor();
      }

      // Save annotations to local storage
      function saveAnnotationsToLocalStorage() {
        const canvasDimensions = {
          width: canvas.width,
          height: canvas.height,
        };

        const data = {
          canvasDimensions,
          annotations,
          brightness,
          contrast,
          imageName: uploadedImage ? uploadedImage.name : null,
          timestamp: new Date().toISOString(),
        };

        localStorage.setItem("annotations", JSON.stringify(data));
      }

      // Download annotations as JSON file
      function downloadAnnotations() {
        const canvasDimensions = {
          width: canvas.width,
          height: canvas.height,
        };

        const data = {
          canvasDimensions,
          annotations,
          brightness,
          contrast,
          imageName: uploadedImage ? uploadedImage.name : null,
          timestamp: new Date().toISOString(),
        };

        const dataString = JSON.stringify(data, null, 2);
        const blob = new Blob([dataString], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const exportFileDefaultName = "annotations.json";

        const linkElement = document.createElement("a");
        linkElement.setAttribute("href", url);
        linkElement.setAttribute("download", exportFileDefaultName);
        document.body.appendChild(linkElement); // Required for Firefox
        linkElement.click();
        document.body.removeChild(linkElement); // Cleanup
        URL.revokeObjectURL(url); // Free up memory
      }

      document
        .querySelector(".top-nav-button i.fa-save")
        .parentElement.addEventListener("click", () => {
          downloadAnnotations();
        });

      // Add these variables
      let isBrightnessMode = false;
      let isContrastMode = false;
      let brightness = 0;
      let contrast = 0;

      // Add event listeners
      document
        .getElementById("brightness-slider")
        .addEventListener("input", updateBrightness);
      document
        .getElementById("contrast-slider")
        .addEventListener("input", updateContrast);

      // Update brightness
      function updateBrightness(e) {
        brightness = e.target.value;
        document.getElementById("brightness-value").innerText = brightness;
        applyImageAdjustments();
      }

      // Update contrast
      function updateContrast(e) {
        contrast = e.target.value;
        document.getElementById("contrast-value").innerText = contrast;
        applyImageAdjustments();
      }

      // Apply image adjustments
      function applyImageAdjustments() {
        const image = document.getElementById("uploaded-image-display");
        image.style.filter = `brightness(${
          100 + parseInt(brightness)
        }%) contrast(${100 + parseInt(contrast)}%)`;
      }

      // Reset function for when switching to other modes
      function resetImageAdjustments() {
        brightness = 0;
        contrast = 0;
        document.getElementById("brightness-slider").value = 0;
        document.getElementById("contrast-slider").value = 0;
        document.getElementById("uploaded-image-display").style.filter = "none";
      }

      // Hide all controls
      function hideAllControls() {
        document.getElementById("overlay-controls").style.display = "none";
        document.getElementById("brightness-controls").style.display = "none";
        document.getElementById("contrast-controls").style.display = "none";
        document.getElementById("polyline-controls").style.display = "none";
        document.getElementById("new-label").style.display = "none";
        document.getElementById("overlay-submit").style.display = "none";
        document.getElementById("leave-annotation-overlay").style.display =
          "none";
        document.getElementById("restart-annotation-overlay").style.display =
          "none";
      }

      // Show all controls
      function showControl(controlId) {
        document.getElementById("overlay-controls").style.display = "block";
        document.getElementById(controlId).style.display = "block";
      }

      // Select annotation mode
      function selectMode(mode) {
        // If the same mode is clicked, do nothing
        if (activeMode === mode) return;

        // Reset states
        currentType = null;
        activeMode = mode;

        // Reset UI
        document
          .querySelectorAll(".annotation-button")
          .forEach((button) => button.classList.remove("active"));
        hideAllControls();

        // Handle mode selection
        switch (mode) {
          case "brightness":
            document
              .getElementById("brightness-button")
              .classList.add("active");
            showControl("brightness-controls");
            break;

          case "contrast":
            document.getElementById("contrast-button").classList.add("active");
            showControl("contrast-controls");
            break;

          case "polyline":
            currentType = "polyline";
            document.getElementById("polyline-button").classList.add("active");
            if (currentPoints.length > 0) {
              showControl("polyline-controls");
            }
            break;

          case "boundingBox":
            currentType = "boundingBox";
            document
              .getElementById("bounding-box-button")
              .classList.add("active");
            break;

          case "pointer":
            currentType = "pointer";
            document.getElementById("pointer-button").classList.add("active");
            break;
        }
      }

      // Save the label input
      function saveLabel() {
        const label = document.getElementById("annotation-label-input").value;
        if (label.trim() !== "") {
          let color = getColorForLabel(label);

          if (currentType === "polyline") {
            currentPoints.push(currentPoints[0]);
            annotations.push({
              type: "polyline",
              points: [...currentPoints],
              label,
              color,
            });
            currentPoints = [];
            finishPolylineButton.style.display = "block";
          } else if (currentType === "boundingBox") {
            // Calculate width and height
            const width = Math.abs(endX - startX);
            const height = Math.abs(endY - startY);
            // Calculate top-left corner
            const x = Math.min(startX, endX);
            const y = Math.min(startY, endY);

            annotations.push({
              type: "boundingBox",
              x,
              y,
              width,
              height,
              label,
              color,
            });
          }

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          redrawAnnotations();
          updateAnnotationList();
          hideAllControls();
          document.getElementById("annotation-label-input").value = "";

          // Save to local storage
          saveAnnotationsToLocalStorage();
        }
      }

      // Cancel the label input
      function cancelLabel() {
        hideAllControls();
        currentPoints = [];
        isDrawing = false;

        if (currentType === "polyline") {
          finishPolylineButton.style.display = "block";
        }
      }

      // Clear annotations and restart the annotation process
      function restartAnnotationProcess() {
        annotations = [];

        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        redrawAnnotations(); // Redraw annotations
        updateAnnotationList(); // Update the list

        contrast = 0;
        brightness = 0;

        document.getElementById("contrast-value").innerText = contrast;
        document.getElementById("brightness-value").innerText = brightness;

        applyImageAdjustments();

        // Remove annotations from local storage
        localStorage.removeItem("annotations");
      }

      // Initialize event listeners
      function initAnnotationTool() {
        document
          .getElementById("bounding-box-button")
          .addEventListener("click", () => selectMode("boundingBox"));
        document
          .getElementById("polyline-button")
          .addEventListener("click", () => selectMode("polyline"));
        document
          .getElementById("pointer-button")
          .addEventListener("click", () => selectMode("pointer"));
        document
          .getElementById("brightness-button")
          .addEventListener("click", () => selectMode("brightness"));
        document
          .getElementById("contrast-button")
          .addEventListener("click", () => selectMode("contrast"));

        document
          .getElementById("brightness-slider")
          .addEventListener("input", updateBrightness);
        document
          .getElementById("contrast-slider")
          .addEventListener("input", updateContrast);

        document
          .getElementById("finish-polyline-button")
          .addEventListener("click", finishPolyline);
        document
          .getElementById("save-label-button")
          .addEventListener("click", saveLabel);
        document
          .getElementById("annotation-label-input")
          .addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              saveLabel();
            }
          });
        document
          .getElementById("cancel-label-button")
          .addEventListener("click", cancelLabel);

        canvas.addEventListener("mousedown", startDrawing);
        canvas.addEventListener("mousemove", drawAnnotation);
        canvas.addEventListener("mouseup", stopDrawing);

        // Add event listeners for "Verlassen" and "Neustart" buttons
        document
          .querySelector(".top-nav-button i.fa-home")
          .parentElement.addEventListener("click", () => {
            document.getElementById("overlay-submit").style.display = "flex";
            document.getElementById("leave-annotation-overlay").style.display =
              "block";
            document.getElementById(
              "restart-annotation-overlay"
            ).style.display = "none";
          });

        document
          .querySelector(".top-nav-button i.fa-refresh")
          .parentElement.addEventListener("click", () => {
            document.getElementById("overlay-submit").style.display = "flex";
            document.getElementById(
              "restart-annotation-overlay"
            ).style.display = "block";
            document.getElementById("leave-annotation-overlay").style.display =
              "none";
          });

        document
          .getElementById("restart-annotation-button")
          .addEventListener("click", () => {
            restartAnnotationProcess();
            hideAllControls(); // Hide all controls
          });

        document
          .getElementById("cancel-restart-annotation-button")
          .addEventListener("click", () => {
            document.getElementById("overlay-submit").style.display = "none";
            document.getElementById(
              "restart-annotation-overlay"
            ).style.display = "none";
          });

        document
          .getElementById("leave-annotation-button")
          .addEventListener("click", () => {
            removeFile();
            hideAllControls(); // Hide all controls
          });

        document
          .getElementById("cancel-leave-annotation-button")
          .addEventListener("click", () => {
            document.getElementById("overlay-submit").style.display = "none";
            document.getElementById("leave-annotation-overlay").style.display =
              "none";
          });

        // Ensure overlay controls are hidden initially
        hideAllControls();
      }

      // Initialize the upload functionality
      initUpload();

      // Call initAnnotationTool to set up event listeners
      initAnnotationTool();
    </script>
    <!-- COPY UNTIL HERE FOR EMBEDDING TOOL IN ScoSci Survey -->
  </body>
</html>
