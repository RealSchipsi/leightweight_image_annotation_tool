<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Annotation Tool</title>
  </head>
  <body
    style="
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
    "
  >
    <style>
      .container {
        border-style: solid;
        border-color: #f3f3f3;
        height: 700px;
        width: 1150px;
        background-color: #ffffff;
        font-family: Arial, Helvetica, sans-serif;
      }

      .uploadContainer {
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      .uploadContainerHeader {
        height: 10%;
        width: 100%;
        display: flex;
      }

      .uploadContainerHeader img {
        margin-left: 5%;
        margin-top: 2.5%;
        height: 97.5%;
      }

      .uploadContainerBody {
        height: 87.5%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      .uploadButton {
        margin-top: 50px;
        background-color: #009682;
        color: #ffffff;
        width: 175px;
        height: 45px;
        border-radius: 25px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .uploadButton:hover {
        background-color: rgba(0, 150, 130, 0.748);
      }

      #annotationContainer {
        display: none;
      }

      .uploadContainerFooter {
        height: 2.5%;
        width: 100%;
        background-color: #009682;
      }

      .annotationContainer {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
      }

      .annotationContainerHead {
        display: flex;
        flex-direction: row;
        height: 7%;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
      }

      .annotationContainerHeadLeft {
        width: 50%;
        display: flex;
        align-items: center;
        padding: 0% 0.5%;
      }

      .annotationContainerHeadLeft img {
        height: 80%;
      }

      .annotationContainerHeadRight {
        display: flex;
        flex-direction: row;
        width: 50%;
        justify-content: flex-end;
        align-items: center;
        padding: 0% 1.5%;
      }

      .topNavBtn {
        border-radius: 7px;
        height: 90%;
        color: #222222;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin-left: 20px;
      }

      .topNavBtn i {
        margin-top: 25%;
        font-size: 15px;
        margin-bottom: -15%;
      }

      .topNavBtn p {
        font-size: 12px;
      }

      .topNavBtn:hover {
        color: rgba(34, 34, 34, 0.748);
      }

      .annotationContainerBody {
        display: flex;
        flex-direction: row;
        height: 93%;
      }

      .annotationContainerBodyLeft {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 3.5%;
      }

      .annotationContainerBodyLeftSection {
        padding-top: 10px;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
      }

      .annotation-btn {
        width: 80%;
        height: 32px;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 10px;
        cursor: pointer;
        color: #222222;
      }

      .annotation-btn:hover {
        color: rgb(34, 34, 34, 0.748);
      }

      .annotation-btn i {
        font-size: 18px;
      }

      .annotation-btn.active {
        background-color: #f3f3f3;
      }

      .annotationContainerBodyCenter {
        width: 80%;
        background-color: #ffffff;
        border-left-style: solid;
        border-left-color: #f3f3f3;
        border-right-style: solid;
        border-right-color: #f3f3f3;
      }

      .finishPolylineBtn {
        position: absolute;
        z-index: 99999999;
        margin-top: -40px;
        margin-left: 27px;
        border-style: solid;
        border-color: #009682;
        color: #009682;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        display: none;
        font-size: 14px;
      }

      .finishPolylineBtn:hover {
        border-color: rgba(0, 150, 130, 0.748);
        color: rgba(0, 150, 130, 0.748);
      }

      .annotationContainerBodyCenter img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        -webkit-user-drag: none; /* Deaktiviert das Ziehen in Webkit-Browsern (Chrome, Safari) */
        user-select: none; /* Verhindert die Text- und Bildeingabe */
      }

      .annotationContainerBodyRight {
        width: 16.5%;
        height: 100%;
      }

      .annotationContainerBodyRightHeader {
        display: flex;
        align-items: center;
        padding-left: 10px;
        height: 5%;
        color: #222222;
      }

      .annotationContainerBodyRightBody {
        height: 95%;
        overflow-y: auto;
      }

      .annotationList {
        list-style-type: none;
        margin: 0;
        padding: 2.5px 0;
      }

      .annotationItem {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
        margin: 2.5px 5px;
        border-bottom-style: solid;
        border-bottom-color: #f3f3f3;
        background-color: #f3f3f35e;
      }

      .annotationItemLeft {
        display: flex;
        flex-direction: column;
        width: 85%;
      }

      .annotationType {
        font-size: 10px;
        color: #222222;
      }

      .annotationLabel {
        font-size: 12px;
        margin: 5px 0;
      }

      .annotationItemLeft input {
        padding: 5px;
        border-radius: 5px;
        border: 1px solid #f3f3f3;
        width: 85%;
      }

      .annotationItemRight {
        width: 15%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .removeAnnotationBtn {
        cursor: pointer;
      }

      .removeAnnotationBtn i {
        color: #222222;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <div class="container">
      <div id="uploadContainer" class="uploadContainer">
        <div class="uploadContainerHeader">
          <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Logo_KIT.svg/1280px-Logo_KIT.svg.png"
            alt=""
          />
        </div>
        <div class="uploadContainerBody">
          <h1>Beginne die Bildannotation</h1>
          <div id="uploadButton" class="uploadButton">Bild hochladen</div>
          <input type="file" id="fileInput" accept="image/*" hidden />
        </div>
        <div class="uploadContainerFooter"></div>
      </div>
      <div id="annotationContainer" class="annotationContainer">
        <div class="annotationContainerHead">
          <div class="annotationContainerHeadLeft">
            <img
              src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Logo_KIT.svg/1280px-Logo_KIT.svg.png"
              alt=""
            />
          </div>
          <div class="annotationContainerHeadRight">
            <div class="topNavBtn">
              <i class="fas fa-save"></i>
              <p>Speichern</p>
            </div>
            <div class="topNavBtn" onclick="removeFile()">
              <i class="fas fa-times"></i>
              <p>Neustart</p>
            </div>
          </div>
        </div>
        <div class="annotationContainerBody">
          <div class="annotationContainerBodyLeft">
            <div class="annotationContainerBodyLeftSection">
              <div id="pointerBtn" class="annotation-btn">
                <i class="fas fa-mouse-pointer"></i>
              </div>
            </div>
            <div class="annotationContainerBodyLeftSection">
              <div id="boundingBoxBtn" class="annotation-btn">
                <i class="fas fa-vector-square"></i>
              </div>
              <div id="polylineBtn" class="annotation-btn">
                <i class="fas fa-draw-polygon"></i>
              </div>
            </div>
          </div>
          <div class="annotationContainerBodyCenter">
            <img id="uploadedImageDisplay" src="" alt="Uploaded Image" />
            <canvas
              id="annotationCanvas"
              width="920"
              height="650"
              style="position: absolute; margin-left: -920px"
            ></canvas>
            <div class="adjustment-controls">
              <label for="brightness-slider">Brightness:</label>
              <input
                id="brightness-slider"
                type="range"
                min="-100"
                max="100"
                value="0"
              />
              <label for="contrast-slider">Contrast:</label>
              <input
                id="contrast-slider"
                type="range"
                min="-100"
                max="100"
                value="0"
              />
            </div>
          </div>
          <div class="annotationContainerBodyRight">
            <div class="annotationContainerBodyRightHeader">
              <h4>Objekte</h4>
            </div>
            <div class="annotationContainerBodyRightBody">
              <ul class="annotationList" id="annotationList"></ul>
            </div>
            <div id="finishPolylineBtn" class="finishPolylineBtn">
              Polylinie beenden
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      // File upload and deletion
      const uploadBtn = document.getElementById("uploadButton");
      const fileInput = document.getElementById("fileInput");
      const uploadedImageDisplay = document.getElementById(
        "uploadedImageDisplay"
      );

      let uploadedImage = null; // Variable to store the uploaded image

      function initUpload() {
        uploadBtn.addEventListener("click", handleUploadClick);
        fileInput.addEventListener("change", handleFileChange);
      }

      function handleUploadClick() {
        fileInput.click(); // Trigger the file input click event
      }

      function handleFileChange(event) {
        if (event.target.files.length > 0) {
          uploadedImage = event.target.files[0]; // Store the uploaded image in the variable

          const reader = new FileReader();
          reader.onload = function (e) {
            uploadedImageDisplay.src = e.target.result; // Set the src attribute
          };
          reader.readAsDataURL(uploadedImage);

          console.log("Bild erfolgreich hochgeladen:", uploadedImage);

          document.getElementById("uploadContainer").style.display = "none";
          document.getElementById("annotationContainer").style.display = "flex";

          // Reset the file input value to ensure change event is triggered next time
          fileInput.value = "";
        }
      }

      function removeFile() {
        const removeButton = document.getElementById("removeButton");

        uploadedImageDisplay.src = ""; // Clears the src attribute to remove the image
        uploadedImage = null;

        console.log("Bild wurde entfernt.");

        document.getElementById("uploadContainer").style.display = "flex";
        document.getElementById("annotationContainer").style.display = "none";

        // Clear annotations
        annotations = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        updateAnnotationList(); // Update the list
      }

      // Initialize the upload functionality
      initUpload();

      // Annotation features
      const canvas = document.getElementById("annotationCanvas");
      const ctx = canvas.getContext("2d");
      const boundingBoxBtn = document.getElementById("boundingBoxBtn");
      const polylineBtn = document.getElementById("polylineBtn");
      const finishPolylineBtn = document.getElementById("finishPolylineBtn");
      const pointerBtn = document.getElementById("pointerBtn");
      let currentType = ""; // Default type
      let startX,
        startY,
        isDrawing = false;
      let currentPoints = []; // For storing polyline points
      let annotations = []; // Array to store all annotations
      let selectedAnnotation = null;
      let offsetX, offsetY;
      let isResizing = false;
      let resizeHandleSize = 10;

      // Initialize buttons with click events
      function initAnnotationTool() {
        boundingBoxBtn.addEventListener("click", () =>
          selectAnnotationType("boundingBox")
        );
        polylineBtn.addEventListener("click", () =>
          selectAnnotationType("polyline")
        );
        finishPolylineBtn.addEventListener("click", finishPolyline);
        pointerBtn.addEventListener("click", () =>
          selectAnnotationType("pointer")
        );

        canvas.addEventListener("mousedown", startDrawing);
        canvas.addEventListener("mousemove", drawAnnotation);
        canvas.addEventListener("mouseup", stopDrawing);
        canvas.addEventListener("mousedown", (e) => {
          e.preventDefault();
          e.stopPropagation();
          // Zeichnen starten
        });
      }

      function updateAnnotationList() {
        const annotationList = document.getElementById("annotationList");
        annotationList.innerHTML = ""; // Clear the current list

        annotations.forEach((ann, index) => {
          const listItem = document.createElement("li");

          // Map the annotation type to a more readable format
          const annotationType =
            ann.type === "boundingBox" ? "Bounding Box" : "Polylinie";

          // Create a complex structure using template literals
          listItem.innerHTML = `
            <div class="annotationItem" style="border: 2px solid ${ann.color}; background-color: ${ann.color}33;">
              <div class="annotationItemLeft">
                <div class="annotationType">${annotationType}</div>
                <input class="annotationLabel" placeholder="Label" value="${ann.label}" />
              </div>
              <div class="annotationItemRight">
                <div class="removeAnnotationBtn">
                  <i class="fas fa-times"></i>  
                </div>
              </div>
            </div>
          `;

          // Add event listener to update the label on input change
          listItem
            .querySelector(".annotationLabel")
            .addEventListener("input", (e) => {
              ann.label = e.target.value;
              redrawAnnotations(); // Redraw annotations with updated labels
            });

          // Add event listener to remove annotation on button click
          listItem
            .querySelector(".removeAnnotationBtn")
            .addEventListener("click", () => removeAnnotation(index));

          // Append the list item to the annotation list
          annotationList.appendChild(listItem);
        });
      }

      function removeAnnotation(index) {
        annotations.splice(index, 1); // Remove the annotation from the array
        updateAnnotationList(); // Update the list
        redrawAnnotations(); // Redraw annotations
      }

      function removeSelectedAnnotation() {
        if (selectedAnnotation) {
          const index = annotations.indexOf(selectedAnnotation);
          if (index !== -1) {
            removeAnnotation(index);
          }
          selectedAnnotation = null;
        }
      }

      function selectAnnotationType(type) {
        currentType = type;
        document
          .querySelectorAll(".annotation-btn")
          .forEach((btn) => btn.classList.remove("active"));

        if (type === "boundingBox") {
          boundingBoxBtn.classList.add("active");
          finishPolylineBtn.style.display = "none"; // Hide the button when switching to bounding box mode
        } else if (type === "polyline") {
          polylineBtn.classList.add("active");
        } else if (type === "pointer") {
          pointerBtn.classList.add("active");
          finishPolylineBtn.style.display = "none"; // Hide the button when switching to pointer mode
        }
      }

      function startDrawing(e) {
        if (currentType === "pointer") {
          selectedAnnotation = getResizeHandleAt(e.offsetX, e.offsetY);
          if (selectedAnnotation) {
            isResizing = true;
            offsetX = e.offsetX;
            offsetY = e.offsetY;
          } else {
            selectedAnnotation = getAnnotationAt(e.offsetX, e.offsetY);
            if (selectedAnnotation) {
              if (selectedAnnotation.type === "boundingBox") {
                offsetX = e.offsetX - selectedAnnotation.x;
                offsetY = e.offsetY - selectedAnnotation.y;
              } else if (selectedAnnotation.type === "polyline") {
                offsetX = e.offsetX;
                offsetY = e.offsetY;
              }
              isDrawing = true;
            }
          }
        } else {
          startX = e.offsetX;
          startY = e.offsetY;
          isDrawing = true;

          if (currentType === "polyline") {
            currentPoints.push({ x: startX, y: startY });
            finishPolylineBtn.style.display = "block"; // Show the button when drawing a polyline
          }
        }
      }

      function drawAnnotation(e) {
        if (!isDrawing && !isResizing) return;

        requestAnimationFrame(() => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          redrawAnnotations();

          if (currentType === "boundingBox") {
            const width = e.offsetX - startX;
            const height = e.offsetY - startY;
            drawBoundingBox(startX, startY, width, height, "#009682");
          } else if (currentType === "polyline" && currentPoints.length > 0) {
            drawPolyline(
              [...currentPoints, { x: e.offsetX, y: e.offsetY }],
              "#009682"
            );
          } else if (currentType === "pointer" && selectedAnnotation) {
            if (isResizing) {
              const handleIndex = selectedAnnotation.handleIndex;
              const ann = selectedAnnotation.annotation;
              if (ann.type === "boundingBox") {
                switch (handleIndex) {
                  case 0: // top-left
                    ann.width += ann.x - e.offsetX;
                    ann.height += ann.y - e.offsetY;
                    ann.x = e.offsetX;
                    ann.y = e.offsetY;
                    break;
                  case 1: // top-middle
                    ann.height += ann.y - e.offsetY;
                    ann.y = e.offsetY;
                    break;
                  case 2: // top-right
                    ann.width = e.offsetX - ann.x;
                    ann.height += ann.y - e.offsetY;
                    ann.y = e.offsetY;
                    break;
                  case 3: // middle-left
                    ann.width += ann.x - e.offsetX;
                    ann.x = e.offsetX;
                    break;
                  case 4: // middle-right
                    ann.width = e.offsetX - ann.x;
                    break;
                  case 5: // bottom-left
                    ann.width += ann.x - e.offsetX;
                    ann.height = e.offsetY - ann.y;
                    ann.x = e.offsetX;
                    break;
                  case 6: // bottom-middle
                    ann.height = e.offsetY - ann.y;
                    break;
                  case 7: // bottom-right
                    ann.width = e.offsetX - ann.x;
                    ann.height = e.offsetY - ann.y;
                    break;
                }
                drawBoundingBox(
                  ann.x,
                  ann.y,
                  ann.width,
                  ann.height,
                  ann.color,
                  true
                ); // Highlight the bounding box when resizing
              } else if (ann.type === "polyline") {
                if (
                  handleIndex === 0 ||
                  handleIndex === ann.points.length - 1
                ) {
                  // Ensure the first and last points remain the same
                  ann.points[0] = { x: e.offsetX, y: e.offsetY };
                  ann.points[ann.points.length - 1] = {
                    x: e.offsetX,
                    y: e.offsetY,
                  };
                } else {
                  ann.points[handleIndex] = { x: e.offsetX, y: e.offsetY };
                }
                drawPolyline(ann.points, ann.color, true);
              }
            } else {
              if (selectedAnnotation.type === "boundingBox") {
                selectedAnnotation.x = e.offsetX - offsetX;
                selectedAnnotation.y = e.offsetY - offsetY;
              } else if (selectedAnnotation.type === "polyline") {
                const dx = e.offsetX - offsetX;
                const dy = e.offsetY - offsetY;
                selectedAnnotation.points = selectedAnnotation.points.map(
                  (point) => ({
                    x: point.x + dx,
                    y: point.y + dy,
                  })
                );
                offsetX = e.offsetX;
                offsetY = e.offsetY;
              }
            }
            redrawAnnotations(true);
            updateAnnotationList(); // Update the list
          }
        });
      }

      function stopDrawing(e) {
        isDrawing = false;
        isResizing = false;
        selectedAnnotation = null;

        if (currentType === "boundingBox") {
          const width = e.offsetX - startX;
          const height = e.offsetY - startY;
          const label = prompt("Label hinzufügen:");
          if (label !== null && label.trim() !== "") {
            annotations.push({
              type: "boundingBox",
              x: startX,
              y: startY,
              width,
              height,
              label,
              color: getRandomColor(), // Assign a random color
            });
            updateAnnotationList(); // Update the list
            redrawAnnotations(); // Redraw annotations
          }
        } else if (currentType === "polyline") {
          currentPoints.push({ x: e.offsetX, y: e.offsetY });
        }
      }

      function finishPolyline() {
        if (currentPoints.length > 1) {
          const label = prompt("Label hinzufügen:");
          if (label !== null && label.trim() !== "") {
            // Add the first point to the end to close the polyline
            currentPoints.push(currentPoints[0]);

            annotations.push({
              type: "polyline",
              points: [...currentPoints],
              label,
              color: getRandomColor(), // Assign a random color
            });
            currentPoints = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            redrawAnnotations(); // Redraw annotations
            updateAnnotationList(); // Update the list
            finishPolylineBtn.style.display = "none"; // Hide the button when finished
          } else {
            currentPoints = []; // Clear the points if the label is not provided
            finishPolylineBtn.style.display = "none"; // Hide the button if canceled
          }
        }
      }

      function drawBoundingBox(x, y, width, height, color, highlight = false) {
        ctx.strokeStyle = highlight ? "#009682" : color;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        ctx.fillStyle = highlight ? "#00968233" : color + "33"; // Set fill color with transparency
        ctx.fillRect(x, y, width, height); // Fill the bounding box
        ctx.fillStyle = highlight ? "#009682" : color; // Set text color
        ctx.font = "12px Arial"; // Set text font

        if (highlight) {
          const handles = [
            { x: x, y: y }, // top-left
            { x: x + width / 2, y: y }, // top-middle
            { x: x + width, y: y }, // top-right
            { x: x, y: y + height / 2 }, // middle-left
            { x: x + width, y: y + height / 2 }, // middle-right
            { x: x, y: y + height }, // bottom-left
            { x: x + width / 2, y: y + height }, // bottom-middle
            { x: x + width, y: y + height }, // bottom-right
          ];
          handles.forEach((handle) => {
            ctx.fillRect(
              handle.x - resizeHandleSize / 2,
              handle.y - resizeHandleSize / 2,
              resizeHandleSize,
              resizeHandleSize
            );
          });
        }
      }

      function drawPolyline(points, color, highlight = false) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        points.forEach((point) => ctx.lineTo(point.x, point.y));
        ctx.strokeStyle = highlight ? "#009682" : color;
        ctx.lineWidth = 2;
        ctx.stroke();
        if (
          points.length > 2 &&
          points[0].x === points[points.length - 1].x &&
          points[0].y === points[points.length - 1].y
        ) {
          ctx.fillStyle = highlight ? "#00968233" : color + "33"; // Set fill color with transparency
          ctx.fill(); // Fill the closed polyline
        }

        if (highlight) {
          points.forEach((point) => {
            ctx.fillStyle = "#009682";
            ctx.fillRect(
              point.x - resizeHandleSize / 2,
              point.y - resizeHandleSize / 2,
              resizeHandleSize,
              resizeHandleSize
            );
          });
        }
      }

      function redrawAnnotations(highlight = false) {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        annotations.forEach((ann) => {
          if (ann.type === "boundingBox") {
            drawBoundingBox(
              ann.x,
              ann.y,
              ann.width,
              ann.height,
              ann.color,
              highlight && ann === selectedAnnotation
            );
            ctx.fillStyle = ann === selectedAnnotation ? "#009682" : ann.color; // Set text color
            ctx.font = "12px Arial"; // Set text font
            ctx.fillText(ann.label, ann.x, ann.y - 5); // Draw label above bounding box
          } else if (ann.type === "polyline") {
            drawPolyline(
              ann.points,
              ann.color,
              highlight && ann === selectedAnnotation
            );
            ctx.fillStyle = ann === selectedAnnotation ? "#009682" : ann.color; // Set text color
            ctx.font = "12px Arial"; // Set text font
            ctx.fillText(ann.label, ann.points[0].x, ann.points[0].y - 5); // Draw label at the start of polyline
          }
        });
      }

      function getAnnotationAt(x, y) {
        for (let i = annotations.length - 1; i >= 0; i--) {
          const ann = annotations[i];
          if (ann.type === "boundingBox") {
            if (
              x >= ann.x &&
              x <= ann.x + ann.width &&
              y >= ann.y &&
              y <= ann.y + ann.height
            ) {
              return ann;
            }
          } else if (ann.type === "polyline") {
            if (isPointInPolygon(ann.points, { x, y })) {
              return ann;
            }
            for (let j = 0; j < ann.points.length - 1; j++) {
              const point1 = ann.points[j];
              const point2 = ann.points[j + 1];
              if (isPointOnLineSegment(point1, point2, { x, y })) {
                return ann;
              }
            }
          }
        }
        return null;
      }

      function isPointOnLineSegment(point1, point2, point) {
        const tolerance = 10; // Increase tolerance for easier selection
        const distance =
          Math.abs(
            (point2.y - point1.y) * point.x -
              (point2.x - point1.x) * point.y +
              point2.x * point1.y -
              point2.y * point1.x
          ) /
          Math.sqrt((point2.y - point1.y) ** 2 + (point2.x - point1.x) ** 2);
        return distance <= tolerance;
      }

      function isPointInPolygon(points, point) {
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
          const xi = points[i].x,
            yi = points[i].y;
          const xj = points[j].x,
            yj = points[j].y;

          const intersect =
            yi > point.y !== yj > point.y &&
            point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function getResizeHandleAt(x, y) {
        for (let i = annotations.length - 1; i >= 0; i--) {
          const ann = annotations[i];
          if (ann.type === "boundingBox") {
            const handles = [
              { x: ann.x, y: ann.y }, // top-left
              { x: ann.x + ann.width / 2, y: ann.y }, // top-middle
              { x: ann.x + ann.width, y: ann.y }, // top-right
              { x: ann.x, y: ann.y + ann.height / 2 }, // middle-left
              { x: ann.x + ann.width, y: ann.y + ann.height / 2 }, // middle-right
              { x: ann.x, y: ann.y + ann.height }, // bottom-left
              { x: ann.x + ann.width / 2, y: ann.y + ann.height }, // bottom-middle
              { x: ann.x + ann.width, y: ann.y + ann.height }, // bottom-right
            ];
            for (let j = 0; j < handles.length; j++) {
              const handle = handles[j];
              if (
                x >= handle.x - resizeHandleSize / 2 &&
                x <= handle.x + resizeHandleSize / 2 &&
                y >= handle.y - resizeHandleSize / 2 &&
                y <= handle.y + resizeHandleSize / 2
              ) {
                return { annotation: ann, handleIndex: j };
              }
            }
          } else if (ann.type === "polyline") {
            for (let j = 0; j < ann.points.length; j++) {
              const point = ann.points[j];
              if (
                x >= point.x - resizeHandleSize / 2 &&
                x <= point.x + resizeHandleSize / 2 &&
                y >= point.y - resizeHandleSize / 2 &&
                y <= point.y + resizeHandleSize / 2
              ) {
                return { annotation: ann, handleIndex: j };
              }
            }
          }
        }
        return null;
      }

      function getRandomColor() {
        const letters = "0123456789ABCDEF";
        let color = "#";
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      function saveAnnotationsToLocalStorage() {
        const canvasDimensions = {
          width: canvas.width,
          height: canvas.height,
        };

        const data = {
          canvasDimensions,
          annotations,
        };

        const dataStr = JSON.stringify(data);
        localStorage.setItem("annotationsData", dataStr);
        alert("Annotations saved to local storage.");
      }

      function downloadAnnotations() {
        const canvasDimensions = {
          width: canvas.width,
          height: canvas.height,
        };

        const data = {
          canvasDimensions,
          annotations,
        };

        const dataStr = JSON.stringify(data, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const exportFileDefaultName = "annotations.json";

        const linkElement = document.createElement("a");
        linkElement.setAttribute("href", url);
        linkElement.setAttribute("download", exportFileDefaultName);
        document.body.appendChild(linkElement); // Required for Firefox
        linkElement.click();
        document.body.removeChild(linkElement); // Cleanup
        URL.revokeObjectURL(url); // Free up memory
      }

      document
        .querySelector(".topNavBtn i.fa-save")
        .parentElement.addEventListener("click", () => {
          saveAnnotationsToLocalStorage();
          downloadAnnotations();
        });

      // Funktion zur Anpassung von Helligkeit und Kontrast
      function adjustImage(brightness, contrast) {
        const image = document.getElementById("uploadedImageDisplay");
        image.style.filter = `brightness(${brightness + 100}%) contrast(${
          contrast + 100
        }%)`;
      }

      // Event Listener für Helligkeits- und Kontrasteinstellungen
      document
        .getElementById("brightness-slider")
        .addEventListener("input", (e) => {
          const brightness = parseInt(e.target.value, 10);
          const contrast = parseInt(
            document.getElementById("contrast-slider").value,
            10
          );
          adjustImage(brightness, contrast);
        });

      document
        .getElementById("contrast-slider")
        .addEventListener("input", (e) => {
          const brightness = parseInt(
            document.getElementById("brightness-slider").value,
            10
          );
          const contrast = parseInt(e.target.value, 10);
          adjustImage(brightness, contrast);
        });

      // Start the annotation tool
      initAnnotationTool();
    </script>
  </body>
</html>
